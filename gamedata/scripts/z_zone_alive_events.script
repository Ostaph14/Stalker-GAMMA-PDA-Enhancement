-- ========================================================================
-- Zone Alive - Event Detection System
-- ========================================================================
-- Purpose: Detect Zone events and trigger conversations
-- Author: Kalish + Claude Code
-- Version: 1.0.0
-- ========================================================================

local core = z_zone_alive_core
local npc_state = z_zone_alive_npc_state

local DEBUG_MODE = false

local function dprintf(...)
    if DEBUG_MODE and ui_mcm and ui_mcm.get("zone_alive/debug") then
        printf("[Zone Alive Events] " .. string.format(...))
    end
end

-- ========================================================================
-- ZONE EVENT QUEUE (for rumor propagation)
-- ========================================================================

local zone_event_queue = {}
local MAX_QUEUE_SIZE = 20

function add_zone_event(event_data)
    -- Add event to queue (FIFO)
    if #zone_event_queue >= MAX_QUEUE_SIZE then
        table.remove(zone_event_queue, 1)  -- Remove oldest
    end

    event_data.time = game.get_game_time()
    event_data.discussed = false
    table.insert(zone_event_queue, event_data)

    dprintf("Added zone event to queue: %s (%s killed by %s at %s)",
            event_data.type, event_data.what or "unknown", event_data.who_name or "unknown", event_data.where or "unknown")
end

function get_nearby_npcs_same_faction(npc_id, radius)
    local nearby = {}
    local se_npc = alife_object(npc_id)
    if not se_npc then return nearby end

    local pos = se_npc.position
    local faction = se_npc:community()

    for id, st in pairs(db.storage) do
        if id ~= npc_id then
            local se_other = alife_object(id)
            if se_other and se_other:community() == faction and se_other.online then
                if se_other.position and se_other.position:distance_to(pos) < radius then
                    table.insert(nearby, id)
                end
            end
        end
    end

    return nearby
end

-- ========================================================================
-- LEGENDARY KILLS (Chimera, Controller, Bloodsucker)
-- ========================================================================

function on_monster_death_legendary(victim, who)
    if not victim or not who then
        return
    end

    local victim_section = victim:section()

    -- Check if it's a legendary mutant
    local legendary_mutants = {
        m_chimera = {name = "Chimera", significance = 9},
        m_controller = {name = "Controller", significance = 8},
        m_controller_old = {name = "Controller", significance = 8},
        m_bloodsucker = {name = "Bloodsucker", significance = 6}
    }

    local mutant_data = legendary_mutants[victim_section]
    if not mutant_data then
        return
    end

    -- Only trigger if significant enough
    if mutant_data.significance < 6 then
        return
    end

    -- ALWAYS log the kill for debugging
    printf("! [ZONE ALIVE] Legendary kill: %s killed by %s", mutant_data.name, who:name() or "Unknown")

    -- Check if helper functions exist
    if not IsStalker then
        printf("! [ZONE ALIVE] WARNING: IsStalker function not found!")
        return
    end

    if not IsStalker(who) then
        printf("! [ZONE ALIVE] Kill was by player, not NPC - no conversation triggered")
        return
    end

    printf("! [ZONE ALIVE] NPC kill detected, attempting to create conversation thread...")

    -- SET EMOTION: Killer becomes proud
    local killer_id = who:id()
    if npc_state and npc_state.set_npc_emotion then
        local intensity = math.min(100, mutant_data.significance * 10)  -- Higher significance = stronger emotion
        npc_state.set_npc_emotion(killer_id, "proud", intensity, 30 * 60)  -- 30 minutes
        printf("! [ZONE ALIVE] Set emotion: NPC %d is now proud (intensity=%d)", killer_id, intensity)

        -- Nearby allies feel inspired (shared pride)
        local nearby_allies = get_nearby_npcs_same_faction(killer_id, 100)
        for _, ally_id in ipairs(nearby_allies) do
            npc_state.set_npc_emotion(ally_id, "proud", intensity / 2, 15 * 60)  -- Weaker, shorter duration
        end
        printf("! [ZONE ALIVE] %d nearby allies also feel proud", #nearby_allies)
    end

    -- Get location
    local location = dynamic_news_helper and dynamic_news_helper.GetPointDescription(who) or "the Zone"

    -- Add to Zone event queue for potential rumors
    add_zone_event({
        type = "legendary_kill",
        who = killer_id,
        who_name = who:character_name() or "Stalker",
        what = mutant_data.name,
        where = location,
        significance = mutant_data.significance
    })

    -- Create conversation thread
    if core and core.create_conversation_thread and core.is_topic_enabled("combat_legendary_kill") then
        -- Get MCM-adjusted max stages (default 4-6)
        local default_max = math.random(4, 6)
        local max_stages = core.get_max_stages_for_topic and core.get_max_stages_for_topic("combat_legendary_kill", default_max) or default_max

        local thread = core.create_conversation_thread({
            topic = "combat_legendary_kill",
            initiator = who:id(),
            max_stages = max_stages,
            emotion = "pride",
            context = {
                who = who:character_name() or "Stalker",
                what = mutant_data.name,
                where = location,
                significance = mutant_data.significance
            }
        })

        if thread then
            dprintf("Created combat thread: %s", thread.id)
        end
    end
end

-- ========================================================================
-- BLOWOUT SURVIVAL
-- ========================================================================

local blowout_in_progress = false
local blowout_survivors = {}

function on_surge_start()
    blowout_in_progress = true
    blowout_survivors = {}
    dprintf("Blowout started, tracking survivors")

    -- SET EMOTION: All NPCs become fearful during blowout
    if npc_state and npc_state.set_npc_emotion and npc_state.get_npc_state then
        for npc_id, st in pairs(db.storage) do
            local state = npc_state.get_npc_state(npc_id)
            if state and state.traits then
                -- Fear intensity based on superstition trait
                local fear_intensity = state.traits.superstition or 50
                npc_state.set_npc_emotion(npc_id, "fearful", fear_intensity, 15 * 60)  -- 15 minutes
            end
        end
        printf("! [ZONE ALIVE] Blowout started - all NPCs are now fearful")
    end
end

function on_surge_end()
    if not blowout_in_progress then
        return
    end

    blowout_in_progress = false

    -- Find NPCs who survived outside
    local survivors = {}

    if db and db.storage then
        for id, npc in pairs(db.storage) do
            if id and alife_object and alife_object(id) then
                local se_npc = alife_object(id)
                if se_npc and IsStalker and IsStalker(se_npc) then
                    -- Check if they were outside (simplified check)
                    if se_npc.online then
                        table.insert(survivors, id)
                    end
                end
            end
        end
    end

    dprintf("Blowout ended, %d survivors", #survivors)

    -- 20% chance to trigger survival story from random survivor
    if #survivors > 0 and math.random(100) <= 20 then
        local survivor_id = survivors[math.random(#survivors)]
        local se_survivor = alife_object(survivor_id)

        if se_survivor and se_survivor.character_name then
            dprintf("Creating survival story for %s", se_survivor:character_name())

            if core and core.create_conversation_thread and core.is_topic_enabled("survival_story") then
                -- Get MCM-adjusted max stages (default 3-5)
                local default_max = math.random(3, 5)
                local max_stages = core.get_max_stages_for_topic and core.get_max_stages_for_topic("survival_story", default_max) or default_max

                core.create_conversation_thread({
                    topic = "survival_story",
                    initiator = survivor_id,
                    max_stages = max_stages,
                    emotion = "relief",
                    context = {
                        who = se_survivor:character_name() or "Stalker",
                        what = "emission",
                        where = "Red Forest",  -- Will be dynamic later
                        count = "1"
                    }
                })
            end
        end
    end
end

-- ========================================================================
-- ARTIFACT FINDS (Economic Gossip)
-- ========================================================================

local rare_artifacts = {
    af_gold_fish = {name = "Goldfish", value = 50000, rarity = 9},
    af_soul = {name = "Soul", value = 45000, rarity = 9},
    af_moonlight = {name = "Moonlight", value = 40000, rarity = 8},
    af_compass = {name = "Compass", value = 30000, rarity = 7}
}

function on_artifact_pickup(item)
    if not item or not item:is_artefact() then
        return
    end

    local section = item:section()
    local artifact_data = rare_artifacts[section]

    -- Only trigger for rare artifacts
    if not artifact_data or artifact_data.rarity < 7 then
        return
    end

    dprintf("Rare artifact found: %s", artifact_data.name)

    -- 30% chance to trigger economic gossip
    if math.random(100) <= 30 then
        if core and core.create_conversation_thread and core.is_topic_enabled("economic_gossip") then
            -- Get finder (actor)
            local finder_name = db.actor and db.actor:character_name() or "Someone"

            -- Get MCM-adjusted max stages (default 2-4)
            local default_max = math.random(2, 4)
            local max_stages = core.get_max_stages_for_topic and core.get_max_stages_for_topic("economic_gossip", default_max) or default_max

            core.create_conversation_thread({
                topic = "economic_gossip",
                initiator = db.actor and db.actor:id() or nil,
                max_stages = max_stages,
                emotion = "excitement",
                context = {
                    who = finder_name,
                    what = artifact_data.name,
                    value = tostring(artifact_data.value),
                    where = "Electro"  -- Will be dynamic
                }
            })
        end
    end
end

-- ========================================================================
-- ROOKIE MISTAKES (Rookie Roasting)
-- ========================================================================

function on_rookie_question()
    -- This would hook into dialogue system (future expansion)
    -- For now, trigger randomly when rookie is near veteran

    dprintf("Rookie roasting triggered")

    if core and core.create_conversation_thread and core.is_topic_enabled("rookie_roasting") then
        core.create_conversation_thread({
            topic = "rookie_roasting",
            max_stages = 2,
            emotion = "sarcastic",
            context = {
                question = "Can't we just use detectors?",
                answer = "Sure, and then walk into the anomaly."
            }
        })
    end
end

-- ========================================================================
-- NPC DEATH (Grief & Vengeance)
-- ========================================================================

function on_npc_death_grief(victim, who)
    if not victim then
        return
    end

    -- Check if helper function exists
    if not IsStalker or not IsStalker(victim) then
        return
    end

    local victim_id = victim:id()
    local victim_name = victim:character_name() or "Stalker"
    local killer_name = "Unknown"
    local killer_type = "unknown"
    local killer_id = nil

    if who then
        if IsStalker and IsStalker(who) then
            killer_name = who:character_name() or "enemy stalker"
            killer_type = "stalker"
            killer_id = who:id()
        elseif IsMonster and IsMonster(who) then
            killer_name = who:section() or "mutant"
            killer_type = "mutant"
        end
    end

    -- SET EMOTION: Friends of victim become grief-stricken, then angry
    -- Only process for online NPCs to avoid performance issues
    if npc_state and npc_state.get_relationship and npc_state.set_npc_emotion and npc_state.modify_relationship and db.OnlineStalkers then
        local friends_found = 0
        for i = 1, #db.OnlineStalkers do
            local npc_id = db.OnlineStalkers[i]
            if npc_id and npc_id ~= victim_id then
                local relationship = npc_state.get_relationship(npc_id, victim_id)
                if relationship and relationship > 30 then
                    -- Friend detected!
                    friends_found = friends_found + 1
                    dprintf("NPC %d was friends with victim %d (relationship=%d), setting grief emotion",
                           npc_id, victim_id, relationship)

                    -- Immediate grief
                    npc_state.set_npc_emotion(npc_id, "grief", 80, 60 * 60)  -- 1 hour

                    -- Hatred for killer
                    if killer_id then
                        npc_state.modify_relationship(npc_id, killer_id, -80)
                    end

                    -- Schedule transition to anger after 1 hour
                    CreateTimeEvent("ZoneAliveEmotions", "GriefToAnger_" .. npc_id, 60 * 60, function()
                        if npc_state and npc_state.set_npc_emotion then
                            npc_state.set_npc_emotion(npc_id, "angry", 60, 30 * 60)  -- 30 min anger
                        end
                        return true
                    end)
                end
            end
        end

        if friends_found > 0 then
            printf("! [ZONE ALIVE] %d online NPCs grieving for victim %d", friends_found, victim_id)
        end
    end

    -- 10% chance to trigger grief conversation
    if math.random(100) > 10 then
        return
    end

    dprintf("Grief conversation for %s (killed by %s)", victim_name, killer_name)

    if core and core.create_conversation_thread then
        -- Get MCM-adjusted max stages (default 2-4)
        local default_max = math.random(2, 4)
        local max_stages = core.get_max_stages_for_topic and core.get_max_stages_for_topic("grief_vengeance", default_max) or default_max

        core.create_conversation_thread({
            topic = "grief_vengeance",
            max_stages = max_stages,
            emotion = "anger",
            context = {
                victim_name = victim_name,
                killer = killer_name,
                killer_type = killer_type,
                where = "combat zone"
            }
        })
    end
end

-- ========================================================================
-- FACTION DEBATES (Random Trigger)
-- ========================================================================

function trigger_faction_debate()
    -- Randomly trigger faction debate (called by periodic tick)
    -- 30% chance per check

    if math.random(100) > 30 then
        return
    end

    -- Find a random online NPC to initiate the debate
    -- Use db.OnlineStalkers for better performance and correctness
    local initiator_npc = nil
    if db and db.OnlineStalkers and #db.OnlineStalkers > 0 then
        initiator_npc = db.OnlineStalkers[math.random(#db.OnlineStalkers)]
    end

    if not initiator_npc then
        dprintf("Faction debate: No online stalkers available")
        return
    end

    dprintf("Faction debate triggered by NPC ID: %d", initiator_npc)

    if core and core.create_conversation_thread and core.is_topic_enabled("faction_debate") then
        -- Get MCM-adjusted max stages (default 3-5)
        local default_max = math.random(3, 5)
        local max_stages = core.get_max_stages_for_topic and core.get_max_stages_for_topic("faction_debate", default_max) or default_max

        core.create_conversation_thread({
            topic = "faction_debate",
            initiator = initiator_npc,  -- NOW HAS AN INITIATOR!
            max_stages = max_stages,
            emotion = "conviction",
            context = {
                topic = "containment",
                duty_view = "Zone must be contained",
                freedom_view = "Zone is evolution"
            }
        })
    end
end

-- ========================================================================
-- ZONE MYTHOLOGY (Creepy Events)
-- ========================================================================

function on_creepy_event(event_type, location)
    -- Triggered by rare zone phenomena

    dprintf("Zone mythology event: %s at %s", event_type, location)

    if core and core.create_conversation_thread and core.is_topic_enabled("zone_mythology") then
        -- Get MCM-adjusted max stages (default 3-5)
        local default_max = math.random(3, 5)
        local max_stages = core.get_max_stages_for_topic and core.get_max_stages_for_topic("zone_mythology", default_max) or default_max

        core.create_conversation_thread({
            topic = "zone_mythology",
            max_stages = max_stages,
            emotion = "fear",
            context = {
                event = event_type,
                where = location,
                description = "Something's wrong here"
            }
        })
    end
end

-- ========================================================================
-- DRUNK PHILOSOPHY (Campfire)
-- ========================================================================

function on_campfire_drunk()
    -- 15% chance when campfire is lit

    if math.random(100) > 15 then
        return
    end

    dprintf("Drunk philosophy triggered")

    if core and core.create_conversation_thread and core.is_topic_enabled("drunk_philosophy") then
        -- Get MCM-adjusted max stages (default 2-4)
        local default_max = math.random(2, 4)
        local max_stages = core.get_max_stages_for_topic and core.get_max_stages_for_topic("drunk_philosophy", default_max) or default_max

        core.create_conversation_thread({
            topic = "drunk_philosophy",
            max_stages = max_stages,
            emotion = "drunk",
            context = {
                question = "What if WE'RE the anomaly?",
                response = "You're drunk"
            }
        })
    end
end

-- ========================================================================
-- OFFLINE COMBAT INTEGRATION
-- ========================================================================

function add_zone_event_from_offline_combat(victory, se_attacker, se_victim, squad_1, squad_2)
    if not se_attacker or not se_victim then
        dprintf("add_zone_event_from_offline_combat: nil attacker or victim")
        return
    end

    -- Safely get NPC names (se_objects don't have character_name method)
    local function get_npc_name(se_obj)
        if not se_obj then return "Unknown" end

        -- Try to get story_object name first
        local story_id = get_object_story_id(se_obj.id)
        if story_id then
            return story_id
        end

        -- Try section name
        if se_obj.section_name then
            local success, section = pcall(function() return se_obj:section_name() end)
            if success and section then
                return section
            end
        end

        return "Stalker"
    end

    -- Determine if this was a significant battle
    local squad_1_size = squad_1 and squad_1:npc_count() or 1
    local squad_2_size = squad_2 and squad_2:npc_count() or 1
    local significance = math.min(10, (squad_1_size + squad_2_size) / 2)

    -- Get location name safely
    local level_name = "the Zone"
    if se_attacker.m_game_vertex_id then
        local success, result = pcall(function()
            return alife():level_name(game_graph():vertex(se_attacker.m_game_vertex_id):level_id())
        end)
        if success and result then
            level_name = result
        end
    end

    local attacker_name = get_npc_name(se_attacker)
    local victim_name = get_npc_name(se_victim)

    -- Add to zone event queue
    add_zone_event({
        type = "offline_combat",
        who = se_attacker.id,
        who_name = attacker_name,
        what = victim_name,
        where = level_name,
        significance = significance,
        victory = victory
    })

    dprintf("Added offline combat event to queue: %s vs %s at %s (significance=%d)",
            attacker_name, victim_name, level_name, significance)
end

-- ========================================================================
-- RUMOR PROPAGATION SYSTEM
-- ========================================================================

function process_rumor_propagation()
    if #zone_event_queue == 0 then
        return
    end

    local now = game.get_game_time()

    for i = #zone_event_queue, 1, -1 do
        local event = zone_event_queue[i]

        -- Remove events older than 2 hours
        if now:diffSec(event.time) > (2 * 60 * 60) then
            table.remove(zone_event_queue, i)
            dprintf("Removed expired event from queue: %s", event.type)
            goto continue
        end

        -- Skip already discussed events
        if event.discussed then
            goto continue
        end

        -- Calculate rumor spread chance based on significance and time
        local age_minutes = now:diffSec(event.time) / 60
        local base_chance = event.significance * 4  -- 0-40% based on significance
        local time_factor = 1.0

        -- Events spread faster over time (more people hear about it)
        if age_minutes > 30 then
            time_factor = 1.5
        elseif age_minutes > 60 then
            time_factor = 2.0
        end

        local spread_chance = math.min(80, base_chance * time_factor)

        if math.random(100) <= spread_chance then
            -- Trigger rumor conversation
            trigger_rumor_conversation(event)
            event.discussed = true
        end

        ::continue::
    end
end

function trigger_rumor_conversation(event)
    -- Find a random online NPC to spread the rumor
    if not db or not db.OnlineStalkers or #db.OnlineStalkers == 0 then
        dprintf("No online stalkers available for rumor spreading")
        return
    end

    -- Use db.OnlineStalkers for better performance
    local spreader_id = db.OnlineStalkers[math.random(#db.OnlineStalkers)]
    if not spreader_id then
        return
    end

    dprintf("NPC %d spreading rumor about: %s", spreader_id, event.type or "unknown")

    -- Create conversation based on event type
    if core and core.create_conversation_thread then
        local topic = "economic_gossip"  -- Default
        local emotion = "neutral"

        if event.type == "legendary_kill" then
            topic = "combat_legendary_kill"
            emotion = "excitement"
        elseif event.type == "offline_combat" then
            topic = "combat_survival"
            emotion = "pride"
        end

        if not core.is_topic_enabled(topic) then
            return
        end

        local default_max = math.random(2, 4)
        local max_stages = core.get_max_stages_for_topic and core.get_max_stages_for_topic(topic, default_max) or default_max

        core.create_conversation_thread({
            topic = topic,
            initiator = spreader_id,
            max_stages = max_stages,
            emotion = emotion,
            context = {
                who = event.who_name or "someone",
                what = event.what or "something",
                where = event.where or "the Zone"
            }
        })
    end
end

-- ========================================================================
-- CALLBACK REGISTRATION
-- ========================================================================

function init()
    dprintf("Initializing event detection")

    -- Monster death (legendary kills)
    RegisterScriptCallback("monster_on_death_callback", on_monster_death_legendary)

    -- NPC death (grief)
    RegisterScriptCallback("npc_on_death_callback", on_npc_death_grief)

    -- Blowout events
    RegisterScriptCallback("actor_on_surge_start", on_surge_start)
    RegisterScriptCallback("actor_on_surge_end", on_surge_end)

    -- Artifact pickup
    RegisterScriptCallback("actor_on_item_take", on_artifact_pickup)

    -- Periodic events (faction debates, etc.)
    -- Check every 2 minutes for dynamic conversations
    CreateTimeEvent("ZoneAliveEvents", "PeriodicCheck", 120, function()
        trigger_faction_debate()
        return false  -- Keep repeating
    end)

    -- Rumor propagation processor (every 3 minutes)
    CreateTimeEvent("ZoneAliveEvents", "RumorProcessor", 180, function()
        process_rumor_propagation()
        return false  -- Keep repeating
    end)

    dprintf("Event detection initialized (with rumor propagation)")
end

function destroy()
    dprintf("Destroying event detection")

    -- Unregister callbacks
    UnregisterScriptCallback("monster_on_death_callback", on_monster_death_legendary)
    UnregisterScriptCallback("npc_on_death_callback", on_npc_death_grief)
    UnregisterScriptCallback("actor_on_surge_start", on_surge_start)
    UnregisterScriptCallback("actor_on_surge_end", on_surge_end)
    UnregisterScriptCallback("actor_on_item_take", on_artifact_pickup)

    RemoveTimeEvent("ZoneAliveEvents", "PeriodicCheck")
    RemoveTimeEvent("ZoneAliveEvents", "RumorProcessor")
end

-- ========================================================================
-- EXPORTS
-- ========================================================================

-- Export functions for other modules (global registration for GAMMA)
if not z_zone_alive_events then
    z_zone_alive_events = {
        init = init,
        destroy = destroy,
        on_creepy_event = on_creepy_event,
        on_campfire_drunk = on_campfire_drunk,
        add_zone_event = add_zone_event,
        add_zone_event_from_offline_combat = add_zone_event_from_offline_combat
    }
end
