--[[
    Kalish's More PDA News - Compatibility Layer

    This script provides monkey-patching (runtime function hooking) to ensure
    compatibility with other mods that modify the same vanilla scripts.

    Instead of overwriting entire script files, we hook into specific functions
    and add our PDA news functionality without breaking other mods.

    Load Order: The 'z_' prefix ensures this loads AFTER vanilla scripts
]]

local SCRIPT_VERSION = "0.2.4_compat"

-- Enable debug logging
local DEBUG_MODE = true

local function dprintf(fmt, ...)
    if DEBUG_MODE then
        printf("[Kalish PDA Compat] " .. fmt, ...)
    end
end

--=============================================================================
-- Module: Offline Combat Patches
--=============================================================================
local function patch_sim_offline_combat()
    dprintf("Patching sim_offline_combat...")

    if not sim_offline_combat then
        dprintf("WARNING: sim_offline_combat module not found!")
        return false
    end

    -- Helper: Get random banter pair
    local function get_random_banter_pair(banter_type)
        local tbl = utils_data.collect_translations(banter_type, true)
        if not tbl then
            return "nil", "nil"
        end
        local msg_pick = tbl[math.random(#tbl)]
        local banter, reply = msg_pick:match("([^|]+)|([^|]+)")
        return banter, reply
    end

    -- Helper: Send battle banter
    local function send_battle_banter(npc_a, npc_b)
        -- Safety: Check if dynamic_news_helper exists
        if not dynamic_news_helper or not dynamic_news_helper.send_tip then
            dprintf("WARNING: dynamic_news_helper.send_tip not available!")
            return
        end

        if not (npc_a and npc_b and npc_a.character_name and npc_b.character_name) then
            return
        end

        local banter, reply = get_random_banter_pair("st_battle_banter_")
        if not banter or banter == "nil" then
            return
        end

        -- Protect against errors in character_name() or character_icon()
        local success, name_a = pcall(function() return npc_a:character_name() end)
        if not success or not name_a then return end

        local success2, icon_a = pcall(function() return npc_a:character_icon() end)
        if not success2 or not icon_a then return end

        -- First banter from npc_a
        dynamic_news_helper.send_tip(banter, name_a, 1, 30, icon_a, "beep_1", "npc")

        -- 75% chance for reply from npc_b
        if math.random(1, 100) > 25 and reply and reply ~= "nil" then
            local success3, name_b = pcall(function() return npc_b:character_name() end)
            local success4, icon_b = pcall(function() return npc_b:character_icon() end)

            if success3 and name_b and success4 and icon_b then
                dynamic_news_helper.send_tip(reply, name_b, math.random(3, 9), 30, icon_b, "beep_2", "npc")

                -- 53% chance for finisher from npc_a
                if math.random(1, 100) > 47 then
                    local tbl = utils_data.collect_translations("st_battle_finisher_", true)
                    if tbl and #tbl > 0 then
                        local msg_pick = tbl[math.random(#tbl)]
                        dynamic_news_helper.send_tip(msg_pick, name_a, math.random(12, 23), 30, icon_a, "beep_1", "npc")
                    end
                end
            end
        end
    end

    -- Helper: Get random NPC from squad (needed for banter)
    local function get_random_npc_from_squad(squad)
        if not squad or not squad.squad_members then return nil end

        local success, squad_npcs = pcall(function()
            local npcs = {}
            for k in squad:squad_members() do
                npcs[#npcs + 1] = k.id
            end
            return npcs
        end)

        if not success or not squad_npcs or #squad_npcs == 0 then
            return nil
        end

        local npc_id = squad_npcs[math.random(#squad_npcs)]
        return alife_object and alife_object(npc_id) or nil
    end

    -- Patch: simulate_battle - Add battle banter
    local original_simulate_battle = sim_offline_combat.simulate_battle
    if original_simulate_battle then
        sim_offline_combat.simulate_battle = function(id_1, id_2, squad_1, squad_2, community_1, community_2, lid)
            -- Get NPCs before battle (they might die)
            local se_attacker = get_random_npc_from_squad(squad_1)
            local se_victim = get_random_npc_from_squad(squad_2)

            -- Call original function
            original_simulate_battle(id_1, id_2, squad_1, squad_2, community_1, community_2, lid)

            -- Add our battle banter (10% chance, 59% of that for actual banter)
            if math.random(1, 100) <= 10 and math.random(1, 100) <= 59 then
                if se_attacker and se_victim then
                    send_battle_banter(se_attacker, se_victim)
                end
            end
        end
        dprintf("  - Patched simulate_battle()")
    end

    -- Patch: set_battle_outcome - Add SOS messages + ZONE ALIVE INTEGRATION
    local original_set_battle_outcome = sim_offline_combat.set_battle_outcome
    if original_set_battle_outcome then
        sim_offline_combat.set_battle_outcome = function(victory, id_1, id_2, squad_1, squad_2, community_1, community_2, se_attacker, se_victim, damage)
            -- Call original function
            original_set_battle_outcome(victory, id_1, id_2, squad_1, squad_2, community_1, community_2, se_attacker, se_victim, damage)

            -- Add our SOS news on defender victory
            if not victory then
                dynamic_news_manager.get_dynamic_news():SOSBattleOffline(squad_2, squad_1)
            end

            -- ZONE ALIVE: Add offline combat events to rumor queue
            if z_zone_alive_events and z_zone_alive_events.add_zone_event_from_offline_combat then
                z_zone_alive_events.add_zone_event_from_offline_combat(victory, se_attacker, se_victim, squad_1, squad_2)
            end
        end
        dprintf("  - Patched set_battle_outcome()")
    end

    dprintf("sim_offline_combat patching complete")
    return true
end

--=============================================================================
-- Module: Wounded NPC Patches
--=============================================================================
local function patch_xr_wounded()
    dprintf("Patching xr_wounded...")

    if not xr_wounded or not xr_wounded.Cwound_manager then
        dprintf("WARNING: xr_wounded.Cwound_manager class not found!")
        return false
    end

    -- Patch: Cwound_manager:eat_medkit - Add medkit usage notification
    local original_eat_medkit = xr_wounded.Cwound_manager.eat_medkit
    if original_eat_medkit then
        xr_wounded.Cwound_manager.eat_medkit = function(self)
            -- Check if we should send news BEFORE eating (while NPC still has medkit)
            local should_send_news = false
            if self.npc and self.npc:object("medkit_script") ~= nil then
                should_send_news = true
            end

            -- Call original function
            original_eat_medkit(self)

            -- Send PDA news about medkit usage
            if should_send_news and dynamic_news_helper and dynamic_news_helper.send_tip then
                local tbl = utils_data.collect_translations("npc_injured_use_medkit_", true)
                if tbl and #tbl > 0 then
                    local msg_pick = tbl[math.random(#tbl)]
                    local success, name = pcall(function() return self.npc:character_name() end)
                    local success2, icon = pcall(function() return self.npc:character_icon() end)
                    if success and name and success2 and icon then
                        dynamic_news_helper.send_tip(msg_pick, name, 1, 10, icon, "beep_2", "npc")
                    end
                end
            end
        end
        dprintf("  - Patched Cwound_manager:eat_medkit()")
    end

    dprintf("xr_wounded patching complete")
    return true
end

--=============================================================================
-- Module: Campfire Patches
--=============================================================================
local campfire_cooldowns = {}  -- Track last campfire message per NPC
local last_global_campfire_message = nil  -- Global cooldown to prevent multiple NPCs talking at once

local function patch_axr_turn_on_campfire()
    dprintf("Patching axr_turn_on_campfire...")

    if not axr_turn_on_campfire then
        dprintf("WARNING: axr_turn_on_campfire module not found!")
        return false
    end

    -- Helper: Get random campfire banter pair
    local function get_random_banter_pair()
        local tbl = utils_data.collect_translations("campfire_on_", true)
        if not tbl then
            return false
        end
        local msg_pick = tbl[math.random(#tbl)]
        local banter, reply = msg_pick:match("([^|]+)|([^|]+)")
        return banter, reply
    end

    -- Helper: Check if NPC is on cooldown
    local function can_send_campfire_message(npc_id)
        -- Global cooldown check (15 minutes between ANY campfire messages)
        if last_global_campfire_message then
            local now = game.get_game_time()
            local elapsed = now:diffSec(last_global_campfire_message)
            if elapsed < (15 * 60) then
                return false  -- Too soon since last campfire message from ANYONE
            end
        end

        -- Per-NPC cooldown check
        if campfire_cooldowns[npc_id] then
            local now = game.get_game_time()
            local elapsed = now:diffSec(campfire_cooldowns[npc_id])

            -- 30 minute cooldown per NPC to prevent spam
            if elapsed < (30 * 60) then
                return false
            end
        end

        return true
    end

    -- Find the evaluator update function (this is tricky without seeing vanilla code)
    -- We'll patch the act_turn_on_campfire action's execute method instead
    if axr_turn_on_campfire.act_turn_on_campfire and axr_turn_on_campfire.act_turn_on_campfire.execute then
        local original_execute = axr_turn_on_campfire.act_turn_on_campfire.execute

        axr_turn_on_campfire.act_turn_on_campfire.execute = function(self)
            -- Call original function
            original_execute(self)

            local npc = self.object
            if not npc or not npc.character_name then
                return
            end

            local npc_id = npc:id()

            -- First check: Very low probability (1% chance) to even attempt
            if math.random(1, 100) > 99 then
                return  -- 99% of the time, don't even bother checking
            end

            -- Second check: Global + per-NPC cooldown
            if not can_send_campfire_message(npc_id) then
                return
            end

            -- Third check passed - send the message
            if dynamic_news_helper and dynamic_news_helper.send_tip then
                local banter, reply = get_random_banter_pair()
                if banter and banter ~= "nil" then
                    local success, name = pcall(function() return npc:character_name() end)
                    local success2, icon = pcall(function() return npc:character_icon() end)
                    if success and name and success2 and icon then
                        dynamic_news_helper.send_tip(banter, name, math.random(12, 23), 10, icon, "beep_1", "npc")

                        -- Update BOTH global and per-NPC cooldown timestamps
                        last_global_campfire_message = game.get_game_time()
                        campfire_cooldowns[npc_id] = game.get_game_time()
                        dprintf("  - Sent campfire message from %s (global + NPC cooldown active)", name)
                    end
                end
            end
        end
        dprintf("  - Patched act_turn_on_campfire:execute() with dual cooldown system")
    end

    dprintf("axr_turn_on_campfire patching complete")
    return true
end

--=============================================================================
-- Module: Tasks Guide Patches
--=============================================================================
local function patch_tasks_guide()
    dprintf("Patching tasks_guide...")

    if not tasks_guide then
        dprintf("WARNING: tasks_guide module not found!")
        return false
    end

    -- No patching needed - we now include the full tasks_guide.script file
    -- which has the correct implementation

    dprintf("tasks_guide loaded (full file included, no patch needed)")
    return true
end

--=============================================================================
-- Main Initialization
--=============================================================================
local function apply_all_patches()
    dprintf("===========================================")
    dprintf("Kalish's PDA News Compatibility Layer v%s", SCRIPT_VERSION)
    dprintf("===========================================")

    local patches_applied = 0
    local patches_failed = 0

    -- Apply patches in order
    if patch_sim_offline_combat() then
        patches_applied = patches_applied + 1
    else
        patches_failed = patches_failed + 1
    end

    if patch_xr_wounded() then
        patches_applied = patches_applied + 1
    else
        patches_failed = patches_failed + 1
    end

    if patch_axr_turn_on_campfire() then
        patches_applied = patches_applied + 1
    else
        patches_failed = patches_failed + 1
    end

    if patch_tasks_guide() then
        patches_applied = patches_applied + 1
    else
        patches_failed = patches_failed + 1
    end

    dprintf("===========================================")
    dprintf("Patching complete: %d applied, %d failed", patches_applied, patches_failed)
    dprintf("===========================================")

    if patches_failed > 0 then
        printf("! [Kalish PDA News] WARNING: %d compatibility patches failed to apply", patches_failed)
    end
end

--=============================================================================
-- Zone Alive Integration
--=============================================================================
local zone_alive_initialized = false

function init_zone_alive()
    if zone_alive_initialized then
        return
    end

    -- Check if MCM setting exists and is enabled
    if ui_mcm and ui_mcm.get("zone_alive/enable") == false then
        dprintf("[Zone Alive] Disabled in MCM")
        return
    end

    -- Initialize Zone Alive core
    if z_zone_alive_core then
        local success, err = pcall(function()
            z_zone_alive_core.init()
        end)

        if success then
            dprintf("[Zone Alive] Core initialized")
        else
            dprintf("[Zone Alive] ERROR initializing core: %s", tostring(err))
            return
        end
    else
        dprintf("[Zone Alive] WARNING: Core module not found")
        return
    end

    -- Initialize event detection
    if z_zone_alive_events then
        local success, err = pcall(function()
            z_zone_alive_events.init()
        end)

        if success then
            dprintf("[Zone Alive] Events initialized")
        else
            dprintf("[Zone Alive] ERROR initializing events: %s", tostring(err))
            return
        end
    else
        dprintf("[Zone Alive] WARNING: Events module not found")
    end

    zone_alive_initialized = true
    dprintf("[Zone Alive] System fully initialized")
end

--=============================================================================
-- Game Start Hook
--=============================================================================
function on_game_start()
    -- Apply patches after all other scripts have loaded
    -- The z_ prefix ensures we load last
    apply_all_patches()

    -- Initialize Zone Alive system
    init_zone_alive()
end
